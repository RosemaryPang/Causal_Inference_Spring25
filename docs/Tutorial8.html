<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Tutorial_8 – DACSS790 Causal Inference Spring 2025</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">DACSS790 Causal Inference Spring 2025</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Tutorial1.html"> 
<span class="menu-text">Tutorial1</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Tutorial2.html"> 
<span class="menu-text">Tutorial2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Tutorial3.html"> 
<span class="menu-text">Tutorial3</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Tutorial4.html"> 
<span class="menu-text">Tutorial4</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Tutorial5.html"> 
<span class="menu-text">Tutorial5</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Tutorial6.html"> 
<span class="menu-text">Tutorial6</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Tutorial7.html"> 
<span class="menu-text">Tutorial7</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./Tutorial8.html" aria-current="page"> 
<span class="menu-text">Tutorial8</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#front-end-matters" id="toc-front-end-matters" class="nav-link active" data-scroll-target="#front-end-matters">Front-end Matters</a></li>
  <li><a href="#exact-matching" id="toc-exact-matching" class="nav-link" data-scroll-target="#exact-matching">Exact Matching</a></li>
  <li><a href="#distance-matching-mahalanobis-distance" id="toc-distance-matching-mahalanobis-distance" class="nav-link" data-scroll-target="#distance-matching-mahalanobis-distance">Distance Matching (Mahalanobis Distance)</a></li>
  <li><a href="#propensity-score-matching" id="toc-propensity-score-matching" class="nav-link" data-scroll-target="#propensity-score-matching">Propensity Score Matching</a></li>
  <li><a href="#coarsened-exact-matching" id="toc-coarsened-exact-matching" class="nav-link" data-scroll-target="#coarsened-exact-matching">Coarsened Exact Matching</a></li>
  <li><a href="#matching-and-regression" id="toc-matching-and-regression" class="nav-link" data-scroll-target="#matching-and-regression">Matching and Regression</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Tutorial 8 Matching</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><strong>Matching</strong> is a powerful tool for causal inference in observational studies. It helps reduce selection bias by constructing a comparison group that closely resembles the treatment group on observed covariates. This tutorial walks you through key types of matching methods and strategies, from simple exact matching to more flexible or model-based approaches. You’ll learn how to implement matching in R, interpret matched results, and decide when to combine matching with regression.</p>
<p>By the end of this tutorial, you will be familiar with:</p>
<p>1. Exact Matching</p>
<p>2. Distance Matching (e.g., Mahalanobis distance)</p>
<p>3. Propensity Score Matching (PSM)</p>
<p>4. Coarsened Exact Matching (CEM)</p>
<p>5.Matching and Regression Adjustment</p>
<section id="front-end-matters" class="level1">
<h1>Front-end Matters</h1>
<p>In this tutorial, we will primarily use the <code>MatchIt</code> package in R, which provides a unified and user-friendly interface for implementing a wide range of matching methods, including exact matching, Mahalanobis distance matching, and propensity score matching. <code>MatchIt</code> is widely used in applied causal inference and integrates smoothly with tools for assessing balance and post-matching analysis. For methods not currently supported by <code>MatchIt</code> – such as Coarsened Exact Matching (CEM) – we will use dedicated package <code>cem</code>. These tools allow us to explore the strengths and limitations of different approaches and understand how implementation choices can affect our causal estimates.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages("MatchIt")</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">#install.packages("cem")</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MatchIt)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cem)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: tcltk</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: lattice</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
How to use CEM? Type vignette("cem")</code></pre>
</div>
</div>
<p>The dataset we’re using for this tutorial is the <em>lalonde</em> dataset from the <code>MatchIt</code> package. It comes from a well-known job training study and includes both treated and control groups, as well as covariates like age, education, race, and pre-treatment earnings. This dataset is widely used in causal inference because it’s simple, real, and flexible—it works well with all the matching methods we’re covering, including exact matching, distance matching, propensity score matching, coarsened exact matching, entropy balancing, and matching combined with regression.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"lalonde"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(lalonde)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     treat age educ   race married nodegree re74 re75       re78
NSW1     1  37   11  black       1        1    0    0  9930.0460
NSW2     1  22    9 hispan       0        1    0    0  3595.8940
NSW3     1  30   12  black       0        0    0    0 24909.4500
NSW4     1  27   11  black       0        1    0    0  7506.1460
NSW5     1  33    8  black       0        1    0    0   289.7899
NSW6     1  22    9  black       0        1    0    0  4056.4940</code></pre>
</div>
</div>
</section>
<section id="exact-matching" class="level1">
<h1>Exact Matching</h1>
<p><strong>Exact matching</strong> is the most straightforward matching method, where treated and control units are matched only if they have identical values on all selected covariates. It guarantees perfect covariate balance within matched pairs or groups, making it conceptually clean and easy to interpret. However, it becomes difficult to implement when covariates are continuous or when there are many variables, as exact matches become increasingly rare. Despite this limitation, exact matching is a valuable foundation for understanding more flexible matching methods and is especially useful in clean, low-dimensional datasets.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>match_single <span class="ot">&lt;-</span> <span class="fu">matchit</span>(treat <span class="sc">~</span> race, <span class="at">data =</span> lalonde, <span class="at">method =</span> <span class="st">"exact"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(match_single)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
matchit(formula = treat ~ race, data = lalonde, method = "exact")

Summary of Balance for All Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
raceblack         0.8432        0.2028          1.7615          .    0.6404
racehispan        0.0595        0.1422         -0.3498          .    0.0827
racewhite         0.0973        0.6550         -1.8819          .    0.5577
           eCDF Max
raceblack    0.6404
racehispan   0.0827
racewhite    0.5577

Summary of Balance for Matched Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
raceblack         0.8432        0.8432               0          .         0
racehispan        0.0595        0.0595               0          .         0
racewhite         0.0973        0.0973               0          .         0
           eCDF Max Std. Pair Dist.
raceblack         0               0
racehispan        0               0
racewhite         0               0

Sample Sizes:
              Control Treated
All               429     185
Matched (ESS)     121     185
Matched           429     185
Unmatched           0       0
Discarded           0       0</code></pre>
</div>
</div>
<p>After performing exact matching on the race variable using the <em>Lalonde</em> dataset, we see that covariate balance improved substantially. Before matching, the distribution of race was highly imbalanced between treated and control groups—for example, 84% of treated units were Black, compared to only 20% of controls. After matching, the race proportions are perfectly aligned across groups, as expected from exact matching: every matched pair has the same race category.</p>
<p>The summary reports that all 185 treated units were matched to 429 control units, with an <strong>effective sample size (ESS)</strong> of 121 for the control group. ESS tells us how much unique, independent information those matched controls contribute—after accounting for weighting or reuse. In the output, the ESS for controls is 121, even though 429 were matched.This means many control units were reused, which is common when matching with replacement.</p>
<p>The key takeaway here is that while exact matching on one variable (race) ensures perfect balance on that variable, it does not address imbalance on other covariates like age or education. Also, although no units were discarded, the ESS reminds us that reuse of controls may reduce precision when estimating treatment effects.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get matched data</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>matched_data <span class="ot">&lt;-</span> <span class="fu">match.data</span>(match_single)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimate ATT as difference in means</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(matched_data<span class="sc">$</span>re78[matched_data<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">1</span>]) <span class="sc">-</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(matched_data<span class="sc">$</span>re78[matched_data<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -635.0262</code></pre>
</div>
</div>
<p>After performing exact matching, we can estimate the treatment effect using the matched data. By taking the difference between the means of treated and control groups, we get the <strong>Average Treatment Effect on the Treated (ATT)</strong>. In this case, the result is –635.03, which means that, on average, individuals who received the treatment earned $635 less than their matched counterparts who did not. While the matching step ensures that the two groups are balanced on the covariate used (race), this negative result suggests that race alone may not be sufficient to control for all confounding. Adding more covariates to the matching process may give a more accurate estimate. That’s why we are matching on multiple variables next.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exact Matching on multiple variables (e.g., race, education, and age)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>match_multi <span class="ot">&lt;-</span> <span class="fu">matchit</span>(treat <span class="sc">~</span> race <span class="sc">+</span> educ <span class="sc">+</span> age, <span class="at">data =</span> lalonde, <span class="at">method =</span> <span class="st">"exact"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(match_multi)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
matchit(formula = treat ~ race + educ + age, data = lalonde, 
    method = "exact")

Summary of Balance for All Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
raceblack         0.8432        0.2028          1.7615          .    0.6404
racehispan        0.0595        0.1422         -0.3498          .    0.0827
racewhite         0.0973        0.6550         -1.8819          .    0.5577
educ             10.3459       10.2354          0.0550     0.4959    0.0347
age              25.8162       28.0303         -0.3094     0.4400    0.0813
           eCDF Max
raceblack    0.6404
racehispan   0.0827
racewhite    0.5577
educ         0.1114
age          0.1577

Summary of Balance for Matched Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
raceblack         0.7500        0.7500               0          .         0
racehispan        0.0694        0.0694               0          .         0
racewhite         0.1806        0.1806               0          .         0
educ             10.5833       10.5833               0     0.9923         0
age              21.6389       21.6389               0     0.9923         0
           eCDF Max Std. Pair Dist.
raceblack         0               0
racehispan        0               0
racewhite         0               0
educ              0               0
age               0               0

Sample Sizes:
              Control Treated
All            429.       185
Matched (ESS)   46.51      72
Matched         85.        72
Unmatched      344.       113
Discarded        0.         0</code></pre>
</div>
</div>
<p>After performing exact matching on multiple covariates (race, educ, and age), the means for all covariates were perfectly aligned between the treated and control groups. This is expected from exact matching, which only retains pairs that are exactly the same on the specified covariates.</p>
<p>However, this improved balance comes at a cost: out of 185 treated units, only 72 could be matched; and from 429 controls, only 85 were used. The ESS for controls drops even further to around 46, reflecting the downweighting of reused or overlapping units. This is a common trade-off with exact matching—perfect balance, but reduced sample size and precision. Still, it serves as a strong baseline for comparing other, more flexible matching methods.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get matched data</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>matched_data <span class="ot">&lt;-</span> <span class="fu">match.data</span>(match_multi)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimate ATT as difference in means</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(matched_data<span class="sc">$</span>re78[matched_data<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">1</span>]) <span class="sc">-</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(matched_data<span class="sc">$</span>re78[matched_data<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] -381.3731</code></pre>
</div>
</div>
<p>The ATT is –381, meaning treated individuals earned $381 less on average than their matched control counterparts. This is smaller (less negative) than our earlier estimate from matching only on race (–635), suggesting that adding more covariates has helped create a more comparable control group and reduced confounding. However, because exact matching on multiple variables is stricter, fewer treated units were matched, which may affect the precision of our estimate.</p>
</section>
<section id="distance-matching-mahalanobis-distance" class="level1">
<h1>Distance Matching (Mahalanobis Distance)</h1>
<p><strong>Distance matching</strong> selects control units for each treated unit based on how similar they are across multiple covariates, using a distance metric like Mahalanobis distance. This approach works well with continuous variables and doesn’t require exact matches. It accounts for differences across all matching variables simultaneously and selects the best matches based on how “close” units are in multivariate space. Below, we use Mahalanobis distance matching to compare treated and control units in the <em>Lalonde</em> dataset based on age, education, and race.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>match_mahal <span class="ot">&lt;-</span> <span class="fu">matchit</span>(treat <span class="sc">~</span> age <span class="sc">+</span> educ <span class="sc">+</span> race,</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">data =</span> lalonde,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">method =</span> <span class="st">"nearest"</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">distance =</span> <span class="st">"mahalanobis"</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">#                      ratio=3</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co"># include this line for k-nearest-neighbor where k=3)</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Summary of matching results</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(match_mahal)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
matchit(formula = treat ~ age + educ + race, data = lalonde, 
    method = "nearest", distance = "mahalanobis")

Summary of Balance for All Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
age              25.8162       28.0303         -0.3094     0.4400    0.0813
educ             10.3459       10.2354          0.0550     0.4959    0.0347
raceblack         0.8432        0.2028          1.7615          .    0.6404
racehispan        0.0595        0.1422         -0.3498          .    0.0827
racewhite         0.0973        0.6550         -1.8819          .    0.5577
           eCDF Max
age          0.1577
educ         0.1114
raceblack    0.6404
racehispan   0.0827
racewhite    0.5577

Summary of Balance for Matched Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
age              25.8162       26.0973         -0.0393     0.6929    0.0316
educ             10.3459       10.5892         -0.1210     0.7775    0.0174
raceblack         0.8432        0.4703          1.0259          .    0.3730
racehispan        0.0595        0.0595          0.0000          .    0.0000
racewhite         0.0973        0.4703         -1.2585          .    0.3730
           eCDF Max Std. Pair Dist.
age          0.0919          0.3460
educ         0.1243          0.3092
raceblack    0.3730          1.0259
racehispan   0.0000          0.0000
racewhite    0.3730          1.2585

Sample Sizes:
          Control Treated
All           429     185
Matched       185     185
Unmatched     244       0
Discarded       0       0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract matched data</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>matched_mahal <span class="ot">&lt;-</span> <span class="fu">match.data</span>(match_mahal)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimate ATT</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(matched_mahal<span class="sc">$</span>re78[matched_mahal<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">1</span>]) <span class="sc">-</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(matched_mahal<span class="sc">$</span>re78[matched_mahal<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 76.39395</code></pre>
</div>
</div>
<p>After performing 1-to-1 Mahalanobis distance matching, we estimate the ATT using the matched sample. The result is 76.39, meaning that treated individuals earned $76 more on average than their matched control counterparts. This positive treatment effect contrasts with earlier estimates from exact matching, which were negative. Matching on multiple continuous covariates using Mahalanobis distance helps improve comparability and may lead to more accurate effect estimates—though we should still assess covariate balance and interpret results cautiously, especially with a modest effect size like this.</p>
</section>
<section id="propensity-score-matching" class="level1">
<h1>Propensity Score Matching</h1>
<p><strong>Propensity Score Matching (PSM)</strong> is a widely used method for reducing selection bias in observational studies. Instead of matching directly on all covariates, PSM first estimates the propensity score—the probability of receiving the treatment given observed covariates – typically using logistic regression. Treated and control units are then matched based on how close their propensity scores are. This simplifies the matching problem to a one-dimensional scale while attempting to balance the distribution of all covariates. Below, we estimate the propensity score and perform nearest-neighbor matching to evaluate the treatment effect.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Propensity score matching (1-to-1 nearest neighbor)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>match_psm <span class="ot">&lt;-</span> <span class="fu">matchit</span>(</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  treat <span class="sc">~</span> age <span class="sc">+</span> educ <span class="sc">+</span> race <span class="sc">+</span> nodegree <span class="sc">+</span> married <span class="sc">+</span> re74 <span class="sc">+</span> re75,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> lalonde,</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">method =</span> <span class="st">"nearest"</span>,           <span class="co"># matching approach</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">distance =</span> <span class="st">"logit"</span>,           <span class="co"># propensity score model </span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">caliper =</span> <span class="fl">0.1</span>,                <span class="co"># optional: only match a control unit if its propensity scoree is within 0.1 of the treated unit's score. Avoid bad matches. </span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">replace =</span> <span class="cn">TRUE</span>                <span class="co"># allow controls to be reused</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Summary of matching result</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(match_psm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
matchit(formula = treat ~ age + educ + race + nodegree + married + 
    re74 + re75, data = lalonde, method = "nearest", distance = "logit", 
    replace = TRUE, caliper = 0.1)

Summary of Balance for All Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
distance          0.5774        0.1822          1.7941     0.9211    0.3774
age              25.8162       28.0303         -0.3094     0.4400    0.0813
educ             10.3459       10.2354          0.0550     0.4959    0.0347
raceblack         0.8432        0.2028          1.7615          .    0.6404
racehispan        0.0595        0.1422         -0.3498          .    0.0827
racewhite         0.0973        0.6550         -1.8819          .    0.5577
nodegree          0.7081        0.5967          0.2450          .    0.1114
married           0.1892        0.5128         -0.8263          .    0.3236
re74           2095.5737     5619.2365         -0.7211     0.5181    0.2248
re75           1532.0553     2466.4844         -0.2903     0.9563    0.1342
           eCDF Max
distance     0.6444
age          0.1577
educ         0.1114
raceblack    0.6404
racehispan   0.0827
racewhite    0.5577
nodegree     0.1114
married      0.3236
re74         0.4470
re75         0.2876

Summary of Balance for Matched Data:
           Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean
distance          0.5746        0.5741          0.0021     0.9878    0.0029
age              25.6776       24.1475          0.2138     0.5351    0.0770
educ             10.3388       10.3716         -0.0163     0.5773    0.0219
raceblack         0.8415        0.8361          0.0150          .    0.0055
racehispan        0.0601        0.0656         -0.0231          .    0.0055
racewhite         0.0984        0.0984          0.0000          .    0.0000
nodegree          0.7049        0.6995          0.0120          .    0.0055
married           0.1913        0.1311          0.1535          .    0.0601
re74           2118.4761     2361.9980         -0.0498     1.0376    0.0410
re75           1505.8050     1482.3283          0.0073     2.1018    0.0648
           eCDF Max Std. Pair Dist.
distance     0.0492          0.0112
age          0.3333          1.2479
educ         0.0601          1.0980
raceblack    0.0055          0.0451
racehispan   0.0055          0.3004
racewhite    0.0000          0.0546
nodegree     0.0055          0.8774
married      0.0601          0.5162
re74         0.2186          0.6154
re75         0.2350          0.6437

Sample Sizes:
              Control Treated
All            429.       185
Matched (ESS)   47.37     183
Matched         82.       183
Unmatched      347.         2
Discarded        0.         0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract matched dataset</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>matched_psm <span class="ot">&lt;-</span> <span class="fu">match.data</span>(match_psm)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimate ATT</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(matched_psm<span class="sc">$</span>re78[matched_psm<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">1</span>]) <span class="sc">-</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(matched_psm<span class="sc">$</span>re78[matched_psm<span class="sc">$</span>treat <span class="sc">==</span> <span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1645.175</code></pre>
</div>
</div>
<p>After performing Propensity Score Matching, we estimate the ATT using the matched dataset. The result is 1645.18, which means that treated individuals earned $1,645 more on average than their matched control counterparts in 1978. This positive effect is substantially larger than the results we observed with exact or Mahalanobis matching. By matching on the estimated probability of receiving treatment – rather than raw covariates – PSM attempts to balance all observed covariates simultaneously. However, this result should be interpreted with caution, as PSM is highly dependent on the correct specification of the propensity score model and may still be sensitive to imbalance or poor overlap.</p>
<p>A Love plot is a simple and effective way to visualize covariate balance before and after matching. It displays the standardized mean differences (SMDs) for each covariate, allowing you to assess how well matching reduced imbalance between treated and control groups. In the plot, you typically want all post-matching dots to fall close to zero (e.g., within ±0.1), indicating good balance.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cobalt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code> cobalt (Version 4.5.5, Build Date: 2024-04-02)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'cobalt'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked _by_ '.GlobalEnv':

    lalonde</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:MatchIt':

    lalonde</code></pre>
</div>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">love.plot</span>(match_psm, <span class="at">threshold =</span> <span class="fl">0.1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: Standardized mean differences and raw mean differences are present in the same plot. 
Use the `stars` argument to distinguish between them and appropriately label the x-axis.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Tutorial8_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>While most covariates show improved balance after propensity score matching, age remains slightly imbalanced, with a standardized mean difference just beyond the ±0.1 threshold. This suggests the PSM model may need to be refined – perhaps by adding interactions, higher-order terms, or considering a caliper restriction to enforce closer matches.</p>
</section>
<section id="coarsened-exact-matching" class="level1">
<h1>Coarsened Exact Matching</h1>
<p><strong>Coarsened Exact Matching (CEM)</strong> is a flexible matching method that improves on traditional exact matching by binning continuous variables into broader categories, or “coarsened” groups. Instead of requiring exact matches on precise values (which can be too strict), CEM allows treated and control units to be matched exactly within coarsened bins, such as age ranges or income brackets. This method balances covariates by design, reduces model dependence, and retains interpretability. It is particularly useful when covariates are a mix of categorical and continuous variables.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># function from cem package</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>cem_out <span class="ot">&lt;-</span> <span class="fu">cem</span>(</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">treatment =</span> <span class="st">"treat"</span>,</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> lalonde,</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">drop =</span> <span class="st">"re78"</span>,  <span class="co"># don't match on outcome</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">cutpoints =</span> <span class="fu">list</span>(</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">age =</span> <span class="fu">c</span>(<span class="dv">20</span>, <span class="dv">25</span>, <span class="dv">30</span>, <span class="dv">35</span>, <span class="dv">40</span>, <span class="dv">45</span>),    </span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">re74 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">5000</span>, <span class="dv">10000</span>, <span class="dv">20000</span>),</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">re75 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">5000</span>, <span class="dv">10000</span>, <span class="dv">20000</span>)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>  )<span class="co"># coarsen continuous variables into bins</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Using 'treat'='1' as baseline group</code></pre>
</div>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(cem_out)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>               Length Class  Mode     
call             3    -none- call     
strata         614    -none- numeric  
n.strata         1    -none- numeric  
vars             7    -none- character
drop             2    -none- character
breaks           6    -none- list     
treatment        1    -none- character
n                1    -none- numeric  
groups         614    factor numeric  
g.names          2    -none- character
n.groups         1    -none- numeric  
group.idx        2    -none- list     
group.len        2    -none- numeric  
mstrata        614    -none- numeric  
mstrataID       33    -none- numeric  
matched        614    -none- logical  
baseline.group   1    -none- character
tab              6    -none- numeric  
k2k              1    -none- logical  
w              614    -none- numeric  </code></pre>
</div>
</div>
<p>This summary gives you the internal structure of the cem object. While it’s not very reader-friendly on its own, here are the most important pieces:</p>
<ul>
<li><p><code>w</code>: This is the vector of weights. Each observation in your dataset gets a weight—usually: 0 if the unit was unmatched; 1 (or higher) if it was matched and kept. These weights are used to estimate the weighted ATT</p></li>
<li><p><code>matched</code>: A logical vector indicating which rows were matched (TRUE) and which were discarded (FALSE).</p></li>
<li><p><code>cutpoints</code> (in breaks): These show how continuous variables (like age, re74, re75) were binned into categories.</p></li>
<li><p><code>tab</code>: Gives counts of how many treated and control units were in each matched stratum.</p></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Estimate ATT manually using matched weights</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>cem_matched <span class="ot">&lt;-</span> lalonde</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>cem_matched<span class="sc">$</span>weights <span class="ot">&lt;-</span> cem_out<span class="sc">$</span>w</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="fu">with</span>(cem_matched, <span class="fu">weighted.mean</span>(re78[treat <span class="sc">==</span> <span class="dv">1</span>], weights[treat <span class="sc">==</span> <span class="dv">1</span>]) <span class="sc">-</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">weighted.mean</span>(re78[treat <span class="sc">==</span> <span class="dv">0</span>], weights[treat <span class="sc">==</span> <span class="dv">0</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 357.244</code></pre>
</div>
</div>
<p>This code calculates the ATT after CEM. It uses the weights assigned by the matching procedure to compute the weighted mean outcome (<code>re78</code>) separately for treated and control units. Then it subtracts the two means to estimate the ATT. In this case, the result is 357.24, meaning that treated individuals earned $357 more on average than their matched control counterparts. This estimate reflects comparisons within well-balanced strata created by coarsening the covariates, making it more robust to model misspecification than some other methods like propensity score matching.</p>
</section>
<section id="matching-and-regression" class="level1">
<h1>Matching and Regression</h1>
<p>After matching, we can further refine our treatment effect estimates by running a regression model on the matched sample. This approach is useful because matching alone may not perfectly balance all covariates or remove all bias. Running a regression on matched data allows us to adjust for any remaining imbalance and can also improve statistical efficiency (e.g., by reducing variance). Importantly, regression after matching is more trustworthy because it is based on better covariate overlap and requires fewer functional form assumptions than regression on the full, unmatched sample.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We already have the matched data</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(cem_matched)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     treat age educ   race married nodegree re74 re75       re78 weights
NSW1     1  37   11  black       1        1    0    0  9930.0460       1
NSW2     1  22    9 hispan       0        1    0    0  3595.8940       1
NSW3     1  30   12  black       0        0    0    0 24909.4500       1
NSW4     1  27   11  black       0        1    0    0  7506.1460       0
NSW5     1  33    8  black       0        1    0    0   289.7899       0
NSW6     1  22    9  black       0        1    0    0  4056.4940       1</code></pre>
</div>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>reg_cem <span class="ot">&lt;-</span> <span class="fu">lm</span>(re78 <span class="sc">~</span> treat <span class="sc">+</span> age <span class="sc">+</span> educ <span class="sc">+</span> race <span class="sc">+</span> nodegree <span class="sc">+</span> married <span class="sc">+</span> re74 <span class="sc">+</span> re75,</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">data =</span> cem_matched,</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">weights =</span> weights)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>reg_original <span class="ot">&lt;-</span> <span class="fu">lm</span>(re78 <span class="sc">~</span> treat <span class="sc">+</span> age <span class="sc">+</span> educ <span class="sc">+</span> race <span class="sc">+</span> nodegree <span class="sc">+</span> married <span class="sc">+</span> re74 <span class="sc">+</span> re75,</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>              <span class="at">data =</span> lalonde)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(reg_cem)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = re78 ~ treat + age + educ + race + nodegree + married + 
    re74 + re75, data = cem_matched, weights = weights)

Weighted Residuals:
   Min     1Q Median     3Q    Max 
-13622      0      0      0  26971 

Coefficients:
              Estimate Std. Error t value Pr(&gt;|t|)  
(Intercept)  2.873e+03  4.572e+03   0.628   0.5305  
treat        6.419e+02  7.871e+02   0.815   0.4158  
age         -5.608e+01  6.373e+01  -0.880   0.3799  
educ         3.945e+02  3.257e+02   1.211   0.2274  
racehispan   4.176e+03  1.844e+03   2.264   0.0247 *
racewhite    7.575e+02  1.406e+03   0.539   0.5907  
nodegree    -1.726e+03  1.360e+03  -1.270   0.2057  
married     -1.787e+03  1.861e+03  -0.960   0.3382  
re74        -8.817e-02  2.308e-01  -0.382   0.7028  
re75         5.126e-01  3.558e-01   1.441   0.1512  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 5522 on 194 degrees of freedom
Multiple R-squared:  0.08608,   Adjusted R-squared:  0.04368 
F-statistic:  2.03 on 9 and 194 DF,  p-value: 0.03789</code></pre>
</div>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(reg_original)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = re78 ~ treat + age + educ + race + nodegree + married + 
    re74 + re75, data = lalonde)

Residuals:
   Min     1Q Median     3Q    Max 
-13595  -4894  -1662   3929  54570 

Coefficients:
              Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) -1.174e+03  2.456e+03  -0.478   0.6328    
treat        1.548e+03  7.813e+02   1.982   0.0480 *  
age          1.298e+01  3.249e+01   0.399   0.6897    
educ         4.039e+02  1.589e+02   2.542   0.0113 *  
racehispan   1.740e+03  1.019e+03   1.708   0.0882 .  
racewhite    1.241e+03  7.688e+02   1.614   0.1071    
nodegree     2.598e+02  8.474e+02   0.307   0.7593    
married      4.066e+02  6.955e+02   0.585   0.5590    
re74         2.964e-01  5.827e-02   5.086 4.89e-07 ***
re75         2.315e-01  1.046e-01   2.213   0.0273 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 6948 on 604 degrees of freedom
Multiple R-squared:  0.1478,    Adjusted R-squared:  0.1351 
F-statistic: 11.64 on 9 and 604 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>After estimating ATT with regression on both the original and the CEM-matched datasets, we observe the following:</p>
<ul>
<li><p>Original Data (no matching): The coefficient for treat is $1,548 and statistically significant (p = 0.048). But this model relies on stronger functional form assumptions and extrapolates across imbalanced groups.</p></li>
<li><p>CEM-Matched Data + Weighted Regression: The coefficient for treat drops to $642 and is not statistically significant (p = 0.416). This model is estimated on a more balanced sample, thanks to coarsened exact matching, and is likely more reliable even if the effect is smaller and noisier.</p></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>